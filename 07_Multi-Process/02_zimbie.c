#include <stdio.h>
#include <unistd.h>

/**
 * 僵尸（zimbie）进程 ：一个已经执行完毕，但其退出状态还没有被其父进程读取的进程。
 * 
 * 产生： 如果父进程没有调用 wait() 来回收这个已经结束的子进程，那么子进程的
 * 进程描述符（PCB）就会一直保留在系统的进程表中。这个状态下的进程就是僵尸进程。
 * 
 * 过程：一个进程完成它的工作后，会调用 exit() 系统调用结束自己。此时，它会留下一个退出状态。
 * 同时内核会向该进程的父进程发送一个 SIGCHLD 信号，通知它应该调用 wait() 或 waitpid() 系统调用
 * 来读取子进程的退出状态。这个过程被称为“回收”子进程。一旦父进程读取了状态，内核就会把这个僵尸进程的
 * 条目从进程表中彻底删除，这个进程就完全消失了。
 * 
 * 特点：
 *  1. 已经死亡： 它不再运行，不占用任何CPU和内存资源（除了进程表里那个条目本身）。
 *  2. 占用资源： 它仍然占用着进程号（PID）。每个系统的PID数量是有限的，如果产生大量僵尸进程且不被清理，
 *     可能会耗尽可用的PID，导致无法创建新进程。
 *  3. 无法用 kill 命令杀死： 因为僵尸进程已经死了，你无法再“杀死”一个已经死掉的东西。kill -9 对它无效。
 * 
 * 你可以使用 ps 命令查看进程状态，僵尸进程的状态标志为 Z。
*/

int main(int argc, char* argv[]) {
    pid_t pid = fork();

    if (pid == 0) {
        puts("Hi, I'm a child process");
    } else {
        printf("Child Process ID: %d \n", pid);
        sleep(30);
    }

    if (pid == 0)
        // 由于父进程沉睡，子进程完成执行后成为僵尸进程
        puts("End child process \n"); 
    else
        puts("End parent process \n");
    return 0;
}

/*
*   经过30s的等待时间后，父进程与僵尸子进程同时销毁 ，可用 ps au 命令查看
*/